

#' Select desired intensity metric
#' Extract LFQ-intensities or iBAQ values from the proteinGroups.txt input as generated by MaxQuant.
#' Further choices are pre-implemented but not supported throughout the rest of the application.
#' @param proteinGroups Full proteinGroups data from MaxQuant algorithm 
#' @param intensityMetric Should be one of "LFQ" or "iBAQ" - others like "uniquepeptides" are possible, but not supported throughout 
#' the rest of the Eatomics Shiny application
#'
#' @return
#' @export
#'
#' @examples
selectProteinData <- function(proteinGroups, intensityMetric) {
  sampleNames = colnames(proteinGroups)
  #n_occur = data.frame(table(as.character(full_proteome$`Gene names`)))
  #full_proteome = full_proteome[which(!full_proteome$`Gene names`==""),]
  
  if (intensityMetric == "conc"){
    ConSampleIndex = grep(pattern = "Concentration.nM.", x= sampleNames)
    ShortConSampleNames=gsub("Concentration.nM.","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "peptides") {
    ConSampleIndex = grep(pattern = "Peptides ", x= sampleNames)
    ShortConSampleNames=gsub("Peptides ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "uniquepeptides"){
    ConSampleIndex = grep(pattern = "Unique peptides ", x= sampleNames)
    ShortConSampleNames=gsub("Unique peptides ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "copynumber"){
    ConSampleIndex = grep(pattern = "Copy number ", x= sampleNames)
    ShortConSampleNames=gsub("Copy number ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "iBAQ"){
    ConSampleIndex = grep(pattern = "iBAQ ", x= sampleNames)
    ShortConSampleNames=gsub("iBAQ ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "LFQ"){
      ConSampleIndex = grep(pattern = "LFQ intensity ", x= sampleNames)
      ShortConSampleNames=gsub("LFQ intensity ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else {return("Please specify the Quantification Method to be conc for Concentration \\[nM], peptides for all Peptides or uniquepeptides for all unique peptides")}
  
  ConSampleNames = colnames(proteinGroups[, ConSampleIndex])
  proteome_quant = proteinGroups[,c("Protein IDs","Majority protein IDs","Gene names", ConSampleNames) ]
  colnames(proteome_quant) = c("Protein IDs","Majority protein IDs","Gene names", ShortConSampleNames)
  proteome_quant = proteome_quant %>% separate(`Gene names`, into = "Gene names", sep = ";", extra = "drop")
  proteome_quant[proteome_quant==0] <- NA
  return(proteome_quant)
}

#' Function to filter proteomic data coming from an object of quantitative proteomics, 
#' which was stripped by selectProteinData() to contain only "Protein IDs","Majority protein IDs","Gene names" + 
#' one quantification column per sample
#' @param proteome_quant A data object as returned by selectProteinData(). Within selectProteinData() all 0's are expected to be replaced by NA's. 
#' @param filterTH A threshold for the minimal detection, i.e. a row/protein/gene needs to be detected in at least filterTH + 1 samples to be returned. At default (filterTH = 0), all "NA" rows are removed. 
#' @return The initial data object, where rows were removed as specified by the filter criteria.

filterProteins = function(proteome_quant, filterTH = 0) {
  proteome_filtered = proteome_quant
  if (filterTH == 0){
    OnlyOnce = which(rowSums(!is.na(proteome_filtered[,-c(1:3)]))==filterTH)
  } else {
    OnlyOnce = which(rowSums(!is.na(proteome_filtered[,-c(1:3)]))<=filterTH)
  }
  if (length(OnlyOnce)!=0) {
    proteome_filtered = proteome_filtered[-OnlyOnce,]
  }
  message("Removed ", length(OnlyOnce), " proteins that were only detected ", filterTH, " times or less in all samples.")
  return(proteome_filtered)
}

## checkForDuplicates() performs 
## 1. a check if duplicate gene names are present
## 2. a quantification of duplicate expression, i.e., the contribution of the duplicates to the overall gene expression
## 3. and information on how many duplicates show lower abundance than 80 % of the overall concentration of the protein
## 4. an aggregation (sum) of the expression on the gene level
## Returns the aggregated data

#' Check for Duplicates
#' For easy data interpretation, we display gene names instead of ProteinIDs. Due to duplicate entries for gene names or due to isoforms
#' present in the data, gene names often are non-unique. Depending on the actual cause of duplicate entries the user may choose to 
#' let Eatomics create unique gene names (default) or to sum entries for one gene with this function. If you don't know the cause for duplicates you should choose to let 
#' Eatomics create unique IDs and to check the data download files for the gene name - proteinID mapping for in depth interpretation. 
#' @param filteredProteins  

checkForDuplicates = function(filteredProteins) {
  n_occur = data.frame(table(as.character(filteredProteins$`Gene names`)))
  summedIsos = n_occur[n_occur$Freq >1,]
  all_occur = filteredProteins[filteredProteins$`Gene names` %in% n_occur$Var1[n_occur$Freq > 1],]
  unique_occur= aggregate(all_occur[,-c(1:3)],all_occur["Gene names"], sum, na.rm = TRUE)
  message("There were ",n_occur$Freq[1]," empty gene names.")
  unique_occur[unique_occur==0] = NA
  
  rowSumsUnique = as.data.frame(rowSums(unique_occur[,-1]))
  rownames(rowSumsUnique) = unique_occur$`Gene names`
  rownames(summedIsos) = na.omit(summedIsos$Var1)
  
  summedIsos = merge(summedIsos, rowSumsUnique, by = "row.names")
  rownames(summedIsos) = summedIsos$Var1
  
  summedIsos = summedIsos[,-1, drop=FALSE]
  
  #Check for Isoform shares, i.e. is there one isoform that dominates the others by showing more than 80% of overall expression of that protein family
  result = NULL
  maxRowPs = NULL
  indices =NULL
  for (i in summedIsos$Var1[-1]){
    indices = which(filteredProteins$`Gene names`==i)
    rowSs = rowSums(filteredProteins[indices, -c(1:3)], na.rm = TRUE)
    rowPs = rowSs/summedIsos[i,"rowSums(unique_occur[, -1])"] * 100
    if (max(rowPs, na.rm = TRUE) < 80){
      result[i] = TRUE
    } else {
      result[i] = FALSE
    }
    maxRowPs[i] = max(rowPs, na.rm = TRUE)
  }
  ##Number of genes were largest isoform expression is below 80% of the overall abundance of all isoforms of the gene
  ListOfGenesIsoBelow80 = which(result == TRUE)
  message("Summed ", length(summedIsos$Var1), " genes for which isoforms were detected. For ", length(ListOfGenesIsoBelow80), " genes/proteins
          the most abundant isoform did not cover over 80% of the complete protein abundance.(",paste0(names(ListOfGenesIsoBelow80), sep = ", "),")")
  unique_prot_conc= aggregate(filteredProteins[,-c(1,2,3)],filteredProteins["Gene names"],sum, na.rm = TRUE)
  unique_prot_conc[unique_prot_conc==0] = NA
  return(unique_prot_conc[-1,])
}



# Experimental setup functions to remove non-overlapping subjects in clinical and in protein abundance
matchedSamples<- function(expDesign, proteinAbundance){
  #expDesign = expDesign %>% rownames_to_column("PatientID")
  l = proteinAbundance %>% colnames()
  r = as.character(expDesign$PatientID)
  Reduce(intersect, list(l, r))
}

matchedExpDesign <- function(expDesign, proteinAbundance){
  expDesign = expDesign %>% rownames_to_column("PatientID")
  proteinAbundance = proteinAbundance %>% column_to_rownames("Gene names") %>% as.data.frame()
  matchedExpDesign <- expDesign %>% filter(PatientID %in% matchedSamples(expDesign, proteinAbundance))
  matchedExpDesign = matchedExpDesign %>% column_to_rownames("PatientID")
  return(matchedExpDesign)
}

# Plots

#' Distribution overview - Creates a sample-wise boxplot of log2-transformed intensity distribution.
#' @param proteinAbundance A tibble containing unique Gene names and Sample columns with protein abundance values as produced by
#' the Eatomics Shiny Application. 
#' @return
#' @export

plot_distribution <- function (proteinAbundance) {
  proteinAbundance <- proteinAbundance %>% gather(key = "PatientID", value = "Abundance")
  ggplot(proteinAbundance, aes(x = PatientID, y = Abundance)) + 
    geom_boxplot(notch = TRUE, na.rm = TRUE) +
    coord_flip() +
    labs(x = "SampleID", y = "Log2-transformed intensity") +
    guides(fill=FALSE) +
    theme_light() +
    scale_color_tableau() 
}


#' Protein Coverage - Creates a plot of sample-wise quantified protein coverage. 
#' @param proteinAbundance  A tibble containing unique Gene names and Sample columns with protein abundance values as produced by
#' the Eatomics Shiny Application. 
#' @return
#' @export

plot_proteinCoverage<-function (proteinAbundance) {
  proteinAbundance <- proteinAbundance %>% gather(key = "SampleID", value = "Number of proteins") %>% group_by(SampleID) %>% summarise_all(list(~sum(!is.na(.))))
  ggplot(proteinAbundance, aes(x= SampleID, y= `Number of proteins`)) +
    geom_col() +
    labs(title = "Measured proteins per sample", x = "", y = "Number of proteins") + 
    guides(fill=FALSE) +
    theme_light() +
    scale_color_tableau() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
}

#' Sample-to-sample heatmap  - Creates a heatmap of sample-to-sample distances based either on correlation coefficient or 
#' euclidean distance
#' @param proteinAbundance  A tibble containing unique Gene names and Sample columns with protein abundance values as produced by
#' the Eatomics Shiny Application. 
#' @param corr A logical stating if the pairwise complete correlation coefficient should be used (= TRUE) or if the Euclidean 
#' distance is used (= FALSE, default)
#'
#' @return
#' @export
#' 
plot_StS_heatmap <- function(proteinAbundance, corr = FALSE){
  if (corr == TRUE) {
    sampleDists = cor(proteinAbundance, use = "pairwise.complete.obs")
  } else {
    sampleDists <- dist(t(proteinAbundance), method = "euclidean")
  }
  sampleDistMatrix <- as.matrix( sampleDists )
  colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
  pheatmap(sampleDistMatrix,
           col = colors,
           main= "Sample to Sample Heatmap",
           legend=TRUE,
           fontsize_row = 8,
           fontsize_col= 8)
}

#' Cumulative intensities plot - Creates a diagram to show cumulative protein intensities over the whole range of detected
#' proteins and a table displaying the top 30 abundant proteins. WIthin the diagram, proteins maing up the first quartile
#' of total intensity are labelled. 
#'
#' @param proteinAbundance A tibble containing unique Gene names and Sample columns with protein abundance values as produced by
#' the Eatomics Shiny Application. 
#' @param plotText Character that enables to manipulate the sample selection annotation within the x-axis of the diagram. 
#' Within the application the plot and axis title default to displaying all samples from the previous selection. 
#'
#' @return
#' @export

plot_CumSumIntensities <- function(proteinAbundance, plotText = "all selected samples"){
  filtered_proteins = proteinAbundance
  samplenames = colnames(filtered_proteins)
  GeneSumControl = sort(rowSums(filtered_proteins[,samplenames], na.rm = TRUE), decreasing = TRUE)
  GeneSumControlPerc = (GeneSumControl/sum(GeneSumControl) )* 100
  #Create color key for plots
  blue = length(which(cumsum(GeneSumControlPerc)<=25))
  green = length(which(cumsum(GeneSumControlPerc)<=50))-blue
  red =  length(which(cumsum(GeneSumControlPerc)>75))
  yellow = length(which(cumsum(GeneSumControlPerc)>50))-red
  colorVector = c(rep("Q1", blue),
                  rep("Q2", green), 
                  rep("Q3", yellow),
                  rep("Q4", red))
  CumSum = data.frame("value" = cumsum(GeneSumControlPerc), "id"  = c(1:length(cumsum(GeneSumControlPerc))), "col" = colorVector, "name" = names(GeneSumControlPerc))
  g2 = tableGrob(CumSum[1:20, c("name","value")], rows = c(1:20), cols = c("Gene Name", "Cum. Intensity"), theme = ttheme_default(base_size = 10)) 
  g1 = ggplot(CumSum, aes(x= CumSum$id, y= CumSum$value, colour=CumSum$col, label=CumSum$name))+
    geom_point() +
    ggtitle("Cumulative Protein Intensities") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))+
    #geom_text(aes(label=ifelse(CumSum$value<50,as.character(name),'')), show.legend = F, hjust = 0, vjust = 0.5,  nudge_x = 70,size = 4) +
    geom_text_repel(aes(label=ifelse(CumSum$value<25,as.character(name),'')), show.legend = F, size = 4) +
    labs(title= , x = paste("Intensity ranked proteins in\n ",plotText), y = "Cumulative protein intesity (%)", col = "Quartiles") +
    scale_color_tableau() +
    theme_light()
  arrangeGrob(g1, g2, ncol = 4, layout_matrix = rbind(c(1,1,1,1,2,2)
                                                      
  ))
}


## Replace missing values from a shifted Gaussian distribution in a perseus-like fashion. 
#Author of this function: Matthias Ziehm, Matthias.Ziehm@mdc-berlin.de

#requires data in log space, with missing values either as -Inf or NA
#if rowMaximumLimit=T, requires minimum 1 valid value per row
#' Title
#'
#' @param data 
#' @param width 
#' @param shift 
#' @param separateColumns 
#' @param rowMaximumLimit 
#'
#' @return
#' @export

replaceMissingFromGaussian = function(data, width=0.3, shift=1.8, separateColumns=T, rowMaximumLimit=F){
  data=apply(data,2, function(x){
    x[is.infinite(x)]=0/0
    return(x)
  }) #substitute +-Inf with NA, which will then be substituted by values from normal distribution
  
  if(rowMaximumLimit==FALSE){
    if(separateColumns==TRUE){
      data=apply(data,2, function(x){
        tempSD=sd(x,na.rm=T)
        x[is.na(x)]=rnorm(length(x[is.na(x)]),mean(x,na.rm=T)-shift*tempSD, width*tempSD)
        return(x)
      })
    }
    else{ #WholeMatrix
      tempSD=sd(unlist(data),na.rm=T)
      data[is.na(data)]=rnorm(length(data[is.na(data)]), mean(unlist(data),na.rm=T)-shift*tempSD, width*tempSD)
    }
  }
  else{ #RowMaximumLimit, i.e. imputed values larger than max measured are rejected
    rowmax=apply(data,1,max,na.rm=T)
    if(sum(is.infinite(rowmax))>0){
      stop("Error: data contains rows with no valid values!")
    }
    if(separateColumns==TRUE){
      data=apply(data,2, function(x){
        tempSD=sd(x,na.rm=T)
        imputes=rnorm(length(x[is.na(x)]),mean(x,na.rm=T)-shift*tempSD, width*tempSD)
        impBool=imputes>rowmax[is.na(x)]
        #cat(length(impBool))
        shift2=shift*1.05
        while(sum(impBool)>0){
          #cat(sum(impBool)," ")
          imputes[impBool]=rnorm(sum(impBool),mean(x,na.rm=T)-shift2*tempSD, width*tempSD)
          impBool=imputes>rowmax[is.na(x)]
          shift2=shift2*1.05
        }
        x[is.na(x)]=imputes
        return(x)
      })
    }
    else{ #WholeMatrix
      tempSD=sd(unlist(data),na.rm=T)
      data=apply(data,2, function(x){ #calculate columnwise here to enable row max check, but using mean and SD of whole table
        imputes=rnorm(length(x[is.na(x)]),mean(unlist(data),na.rm=T)-shift*tempSD, width*tempSD)
        impBool=imputes>rowmax[is.na(x)]
        #cat(length(impBool))
        shift2=shift*1.05
        while(sum(impBool)>0){
          #cat(sum(impBool)," ")
          imputes[impBool]=rnorm(sum(impBool),mean(unlist(data),na.rm=T)-shift2*tempSD, width*tempSD)
          impBool=imputes>rowmax[is.na(x)]
          shift2=shift2*1.05
        }
        x[is.na(x)]=imputes
        return(x)
      })
    }
  }
  return(data)
}

#### ID Maker by R-bloggers ###
idmaker <- function(x){
  max.val = x*100
  count <- nchar(as.character(max.val))                       # find out how many 'numbers' each ID will have after the letter
  size <- paste("%0",count,"d",sep="")                        # set the variable to be fed into 'sprintf' to ensure we have leading 0's
  lets <- toupper(sample(letters,x, replace=T))               # randomising the letters 
  nums <- sprintf(size, sample(1:max.val))[1:x]               # randominsing the numbers, and ensuing they all have the same number of characters
  ids <- paste(lets,nums,sep="")                              # joining them together
  return(ids[1])
}
