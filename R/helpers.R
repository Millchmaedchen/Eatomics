

#' Select desired intensity metric
#' Extract LFQ-intensities or iBAQ values from the proteinGroups.txt input as generated by MaxQuant
#' Further choices are pre-implemented but not supported throughout the rest of the application
#' @param proteinGroups Full proteinGroups data from MaxQuant algorithm 
#' @param intensityMetric Should be one of "LFQ" or "iBAQ" - others like "uniquepeptides" are possible, but not supported throughout 
#' the Eatomics Shiny application
#'
#' @return
#' @export
#'
#' @examples
selectProteinData <- function(proteinGroups, intensityMetric) {
  sampleNames = colnames(proteinGroups)
  #n_occur = data.frame(table(as.character(full_proteome$`Gene names`)))
  #full_proteome = full_proteome[which(!full_proteome$`Gene names`==""),]
  
  if (intensityMetric == "conc"){
    ConSampleIndex = grep(pattern = "Concentration.nM.", x= sampleNames)
    ShortConSampleNames=gsub("Concentration.nM.","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "peptides") {
    ConSampleIndex = grep(pattern = "Peptides ", x= sampleNames)
    ShortConSampleNames=gsub("Peptides ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "uniquepeptides"){
    ConSampleIndex = grep(pattern = "Unique peptides ", x= sampleNames)
    ShortConSampleNames=gsub("Unique peptides ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "copynumber"){
    ConSampleIndex = grep(pattern = "Copy number ", x= sampleNames)
    ShortConSampleNames=gsub("Copy number ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "iBAQ"){
    ConSampleIndex = grep(pattern = "iBAQ ", x= sampleNames)
    ShortConSampleNames=gsub("iBAQ ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else if(intensityMetric == "LFQ"){
      ConSampleIndex = grep(pattern = "LFQ intensity ", x= sampleNames)
      ShortConSampleNames=gsub("LFQ intensity ","", colnames(proteinGroups[, ConSampleIndex]))
  }
  else {return("Please specify the Quantification Method to be conc for Concentration \\[nM], peptides for all Peptides or uniquepeptides for all unique peptides")}
  
  ConSampleNames = colnames(proteinGroups[, ConSampleIndex])
  proteome_quant = proteinGroups[,c("Protein IDs","Majority protein IDs","Gene names", ConSampleNames) ]
  colnames(proteome_quant) = c("Protein IDs","Majority protein IDs","Gene names", ShortConSampleNames)
  proteome_quant = proteome_quant %>% separate(`Gene names`, into = "Gene names", sep = ";", extra = "drop")
  proteome_quant[proteome_quant==0] <- NA
  return(proteome_quant)
}

#' Function to filter proteomic data coming from an object of quantitative proteomics, 
#' which was stripped by selectProteinData() to contain only "Protein IDs","Majority protein IDs","Gene names" + 
#' one quantification column per sample
#' @param proteome_quant A data object as returned by selectProteinData(). Within selectProteinData() all 0's are expected to be replaced by NA's. 
#' @param filterTH A threshold for the minimal detection, i.e. a row/protein/gene needs to be detected in at least filterTH + 1 samples to be returned. At default (filterTH = 0), all "NA" rows are removed. 
#' @return The initial data object, where rows were removed as specified by the filter criteria.

filterProteins = function(proteome_quant, filterTH = 0) {
  proteome_filtered = proteome_quant
  if (filterTH == 0){
    OnlyOnce = which(rowSums(!is.na(proteome_filtered[,-c(1:3)]))==filterTH)
  } else {
    OnlyOnce = which(rowSums(!is.na(proteome_filtered[,-c(1:3)]))<=filterTH)
  }
  if (length(OnlyOnce)!=0) {
    proteome_filtered = proteome_filtered[-OnlyOnce,]
  }
  message("Removed ", length(OnlyOnce), " proteins that were only detected ", filterTH, " times or less in all samples.")
  return(proteome_filtered)
}

## checkForDuplicates() performs 
## 1. a check if duplicate gene names are present
## 2. a quantification of duplicate expression, i.e., the contribution of the duplicates to the overall gene expression
## 3. and information on how many duplicates show lower abundance than 80 % of the overall concentration of the protein
## 4. an aggregation (sum) of the expression on the gene level
## Returns the aggregated data

#' Check for Duplicates
#' For easy data interpretation, we display gene names instead of ProteinIDs. Due to duplicate entries for gene names or due to isoforms
#' present in the data, gene names often are non-unique. Depending on the actual cause of duplicate entries the user may choose to 
#' let Eatomics create unique gene names (default) or to sum entries for one gene with this function. If you don't know the cause for duplicates you should choose to let 
#' Eatomics create unique IDs and to check the data download files for the gene name - proteinID mapping for in depth interpretation. 
#' @param filteredProteins  

checkForDuplicates = function(filteredProteins) {
  n_occur = data.frame(table(as.character(filteredProteins$`Gene names`)))
  summedIsos = n_occur[n_occur$Freq >1,]
  all_occur = filteredProteins[filteredProteins$`Gene names` %in% n_occur$Var1[n_occur$Freq > 1],]
  unique_occur= aggregate(all_occur[,-c(1:3)],all_occur["Gene names"], sum, na.rm = TRUE)
  message("There were ",n_occur$Freq[1]," empty gene names.")
  unique_occur[unique_occur==0] = NA
  
  rowSumsUnique = as.data.frame(rowSums(unique_occur[,-1]))
  rownames(rowSumsUnique) = unique_occur$`Gene names`
  rownames(summedIsos) = na.omit(summedIsos$Var1)
  
  summedIsos = merge(summedIsos, rowSumsUnique, by = "row.names")
  rownames(summedIsos) = summedIsos$Var1
  
  summedIsos = summedIsos[,-1, drop=FALSE]
  
  #Check for Isoform shares, i.e. is there one isoform that dominates the others by showing more than 80% of overall expression of that protein family
  result = NULL
  maxRowPs = NULL
  indices =NULL
  for (i in summedIsos$Var1[-1]){
    indices = which(filteredProteins$`Gene names`==i)
    rowSs = rowSums(filteredProteins[indices, -c(1:3)], na.rm = TRUE)
    rowPs = rowSs/summedIsos[i,"rowSums(unique_occur[, -1])"] * 100
    if (max(rowPs, na.rm = TRUE) < 80){
      result[i] = TRUE
    } else {
      result[i] = FALSE
    }
    maxRowPs[i] = max(rowPs, na.rm = TRUE)
  }
  ##Number of genes were largest isoform expression is below 80% of the overall abundance of all isoforms of the gene
  ListOfGenesIsoBelow80 = which(result == TRUE)
  message("Summed ", length(summedIsos$Var1), " genes for which isoforms were detected. For ", length(ListOfGenesIsoBelow80), " genes/proteins
          the most abundant isoform did not cover over 80% of the complete protein abundance.(",paste0(names(ListOfGenesIsoBelow80), sep = ", "),")")
  unique_prot_conc= aggregate(filteredProteins[,-c(1,2,3)],filteredProteins["Gene names"],sum, na.rm = TRUE)
  unique_prot_conc[unique_prot_conc==0] = NA
  return(unique_prot_conc[-1,])
}



# Experimental setup functions to remove non-overlapping subjects in clinical and in protein abundance
matchedSamples<- function(expDesign, proteinAbundance){
  #expDesign = expDesign %>% rownames_to_column("PatientID")
  l = proteinAbundance %>% colnames()
  r = as.character(expDesign$PatientID)
  Reduce(intersect, list(l, r))
}

matchedExpDesign <- function(expDesign, proteinAbundance){
  expDesign = expDesign %>% rownames_to_column("PatientID")
  proteinAbundance = proteinAbundance %>% column_to_rownames("Gene names") %>% as.data.frame()
  matchedExpDesign <- expDesign %>% filter(PatientID %in% matchedSamples(expDesign, proteinAbundance))
  matchedExpDesign = matchedExpDesign %>% column_to_rownames("PatientID")
  return(matchedExpDesign)
}
